{"ast":null,"code":"import * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\nexport default (canvas => {\n  var scene, renderer, camera;\n  let rot = true;\n  let zoomLevel = 0;\n  let zoomSpeed = 20;\n  let materials = [[], [], [], []]; //\n\n  init();\n  render();\n\n  function rotateAboutPoint(obj, point, axis, theta, pointIsWorld) {\n    pointIsWorld = pointIsWorld === undefined ? false : pointIsWorld;\n\n    if (pointIsWorld) {\n      obj.parent.localToWorld(obj.position); // compensate for world coordinate\n    }\n\n    obj.position.sub(point); // remove the offset\n\n    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\n\n    obj.position.add(point); // re-add the offset\n\n    if (pointIsWorld) {\n      obj.parent.worldToLocal(obj.position); // undo world coordinates compensation\n    }\n\n    obj.rotateOnAxis(axis, theta); // rotate the OBJECT\n  }\n\n  function init() {\n    renderer = new THREE.WebGLRenderer({\n      canvas: canvas,\n      antialias: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    window.addEventListener('resize', () => {\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n    });\n    document.body.appendChild(renderer.domElement);\n    scene = new THREE.Scene();\n    let origin = new THREE.Vector3(0, 0, 0);\n    let originAxis = new THREE.Vector3(0, 1, 0);\n\n    for (let i = 0; i < materials.length; i++) {\n      var texture = new THREE.TextureLoader().load('/materials/00/00_00.jpg');\n      let material = new THREE.MeshBasicMaterial({\n        map: texture\n      });\n      material.side = THREE.DoubleSide;\n      var geometry = new THREE.PlaneGeometry(30, 5, 32);\n      var plane = new THREE.Mesh(geometry, material);\n      plane.position.set(scene.position.x, scene.position.y, -220);\n      scene.add(plane);\n      rotateAboutPoint(plane, origin, originAxis, (i + 1) * Math.PI / 8, true);\n    }\n\n    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.01, 1000);\n    document.addEventListener(\"keydown\", onDocumentKeyDown, false);\n\n    function onDocumentKeyDown(event) {\n      let keyCode = event.which;\n\n      if (keyCode === 87) {\n        camera.translateZ(-zoomSpeed);\n        zoomLevel += 1;\n\n        if (zoomLevel === 0) {\n          rot = true;\n        } else {\n          rot = false;\n        }\n      } else if (keyCode === 83) {\n        if (zoomLevel > 0) {\n          camera.translateZ(zoomSpeed);\n          zoomLevel -= 1;\n        }\n\n        if (zoomLevel === 0) {\n          rot = true;\n        } else {\n          rot = false;\n        }\n      } else if (keyCode === 65 && rot) {\n        camera.rotation.y += Math.PI / 8;\n      } else if (keyCode === 68 && rot) {\n        camera.rotation.y -= Math.PI / 8;\n      }\n    }\n\n    var radius = 1000;\n    var radials = 16;\n    var circles = 20;\n    var divisions = 64;\n    var polarGrid = new THREE.PolarGridHelper(radius, radials, circles, divisions);\n    polarGrid.position.set(0, -10, 0);\n    scene.add(polarGrid);\n    document.addEventListener(\"click\", returnOrigin);\n\n    function returnOrigin() {\n      camera.translateZ(zoomLevel * zoomSpeed);\n      zoomLevel = 0;\n      rot = true;\n    } //TWEEN\n    // let posX;\n    // let posY;\n    // let posZ;\n    //\n    // var from = {\n    //   x : camera.position.x,\n    //   y : camera.position.y,\n    //   z : camera.position.z\n    // };\n    //\n    // var to = {\n    //   x : posX,\n    //   y : posY,\n    //   z : posZ\n    // };\n    // var tween = new TWEEN.Tween(from)\n    // .to(to,600)\n    // .easing(TWEEN.Easing.Linear.None)\n    // .onUpdate(function () {\n    //   camera.position.set(this.x, this.y, this.z);\n    //   // camera.lookAt(new THREE.Vector3(0,0,0));\n    // })\n    // // .onComplete(function () {\n    // //   camera.lookAt(new THREE.Vector3(0,0,0));\n    // // })\n    // .start();\n\n  }\n\n  function render() {\n    TWEEN.update();\n    requestAnimationFrame(render);\n    renderer.render(scene, camera);\n  }\n\n  return {\n    render\n  };\n});","map":{"version":3,"sources":["/Users/gils/dev/shackleton/src/SceneManager.js"],"names":["THREE","TWEEN","canvas","scene","renderer","camera","rot","zoomLevel","zoomSpeed","materials","init","render","rotateAboutPoint","obj","point","axis","theta","pointIsWorld","undefined","parent","localToWorld","position","sub","applyAxisAngle","add","worldToLocal","rotateOnAxis","WebGLRenderer","antialias","setSize","window","innerWidth","innerHeight","addEventListener","aspect","updateProjectionMatrix","document","body","appendChild","domElement","Scene","origin","Vector3","originAxis","i","length","texture","TextureLoader","load","material","MeshBasicMaterial","map","side","DoubleSide","geometry","PlaneGeometry","plane","Mesh","set","x","y","Math","PI","PerspectiveCamera","onDocumentKeyDown","event","keyCode","which","translateZ","rotation","radius","radials","circles","divisions","polarGrid","PolarGridHelper","returnOrigin","update","requestAnimationFrame"],"mappings":"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","sourcesContent":["import * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js'\n\nexport default canvas => {\n\n\n  var scene, renderer, camera;\n  let rot = true;\n  let zoomLevel = 0;\n  let zoomSpeed = 20;\n  let materials = [[],[],[],[]];\n\n//\n  init();\n  render();\n\n  function rotateAboutPoint(obj, point, axis, theta, pointIsWorld){\n    pointIsWorld = (pointIsWorld === undefined)? false : pointIsWorld;\n\n    if(pointIsWorld){\n        obj.parent.localToWorld(obj.position); // compensate for world coordinate\n    }\n\n    obj.position.sub(point); // remove the offset\n    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\n    obj.position.add(point); // re-add the offset\n\n    if(pointIsWorld){\n        obj.parent.worldToLocal(obj.position); // undo world coordinates compensation\n    }\n\n    obj.rotateOnAxis(axis, theta); // rotate the OBJECT\n}\n\n  function init()\n  {\n      renderer = new THREE.WebGLRenderer( {canvas:canvas, antialias:true} );\n\n      renderer.setSize( window.innerWidth, window.innerHeight );\n      window.addEventListener('resize', ()=>{\n        renderer.setSize( window.innerWidth, window.innerHeight );\n        camera.aspect = window.innerWidth / window.innerHeight\n        camera.updateProjectionMatrix()\n      })\n\n      document.body.appendChild (renderer.domElement);\n\n      scene = new THREE.Scene();\n\n      let origin = new THREE.Vector3(0,0,0);\n      let originAxis = new THREE.Vector3(0,1,0);\n\n      for (let i = 0; i < materials.length; i++){\n        var texture = new THREE.TextureLoader().load( '/materials/00/00_00.jpg' );\n        let material = new THREE.MeshBasicMaterial( { map: texture } );\n        material.side = THREE.DoubleSide;\n        var geometry = new THREE.PlaneGeometry( 30, 5, 32 );\n        var plane = new THREE.Mesh( geometry, material );\n        plane.position.set (scene.position.x, scene.position.y, -220);\n        scene.add( plane );\n        rotateAboutPoint(plane, origin, originAxis, (i+1) * Math.PI / 8, true);\n      }\n\n\n      camera = new THREE.PerspectiveCamera( 65, window.innerWidth / window.innerHeight, 0.01, 1000 );\n\n      document.addEventListener(\"keydown\", onDocumentKeyDown, false)\n       function onDocumentKeyDown(event) {\n         let keyCode = event.which\n         if (keyCode === 87) {\n           camera.translateZ(-zoomSpeed)\n           zoomLevel += 1;\n           if (zoomLevel === 0){\n             rot = true;\n           } else {\n             rot = false;\n           }\n         } else if (keyCode === 83) {\n           if (zoomLevel > 0){\n             camera.translateZ(zoomSpeed)\n             zoomLevel -=  1;\n           }\n           if (zoomLevel === 0){\n             rot = true;\n           } else {\n             rot = false;\n           }\n         }\n\n         else if (keyCode === 65 && rot) {\n           camera.rotation.y += Math.PI / 8\n         }\n         else if (keyCode === 68 && rot) {\n           camera.rotation.y -= Math.PI / 8\n         }\n       }\n\n      var radius = 1000;\n      var radials = 16;\n      var circles = 20;\n      var divisions = 64;\n\n      var polarGrid = new THREE.PolarGridHelper( radius, radials, circles, divisions);\n      polarGrid.position.set(0, -10, 0);\n      scene.add( polarGrid );\n\n      document.addEventListener(\"click\", returnOrigin);\n\n      function returnOrigin() {\n        camera.translateZ(zoomLevel * zoomSpeed)\n        zoomLevel = 0;\n        rot = true;\n      }\n\n      //TWEEN\n\n      // let posX;\n      // let posY;\n      // let posZ;\n      //\n      // var from = {\n      //   x : camera.position.x,\n      //   y : camera.position.y,\n      //   z : camera.position.z\n      // };\n      //\n      // var to = {\n      //   x : posX,\n      //   y : posY,\n      //   z : posZ\n      // };\n      // var tween = new TWEEN.Tween(from)\n      // .to(to,600)\n      // .easing(TWEEN.Easing.Linear.None)\n      // .onUpdate(function () {\n      //   camera.position.set(this.x, this.y, this.z);\n      //   // camera.lookAt(new THREE.Vector3(0,0,0));\n      // })\n      // // .onComplete(function () {\n      // //   camera.lookAt(new THREE.Vector3(0,0,0));\n      // // })\n      // .start();\n\n  }\n\n  function render()\n  {\n    TWEEN.update();\n    requestAnimationFrame ( render );\n    renderer.render (scene, camera);\n  }\n\n    return{render}\n\n}\n"]},"metadata":{},"sourceType":"module"}